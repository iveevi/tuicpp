@project cpp
@noentry

@source

// Lexical types
enum {
	NONE,
	TYPE,
	KEYWORD
};

nabu::ret mk_type(int type, const std::string &str) {
	return nabu::ret(new nabu::Tret <nabu::mt_ret> ({
		type,
		nabu::ret(new nabu::Tret <std::string> (str))
	}));
}

nabu::ret mk_type(int type, nabu::ret rptr) {
	return mk_type(type, nabu::get <std::string> (rptr));
}

@rules

sh_type := "int" | "double"

sh_keyword := "if" | "else" | "while" | "for" | "return" | "break" | "continue"
	| "struct" | "class" | "typename" | "enum" | "typedef" | "union"
	| "namespace" | "using" | "template" | "new" | "delete"

sh_none := word
	| space {
		char c = nabu::get <char> (_val);
		std::string str(1, c);
		return ret(new nabu::Tret <std::string> (str));
	}

sh_main := sh_type {return mk_type(TYPE, _val);}
	| sh_keyword {return mk_type(KEYWORD, _val);}
	| sh_none {return mk_type(NONE, _val);}