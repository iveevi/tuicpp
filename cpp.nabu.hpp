
/**
 * This file was generated by Nabu (https://github.com/vedavamadathil/nabu).
 * 
 * "MIT License
 * 
 * Copyright (c) 2021 Venkataram Edavamadathil Sivaram
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE."
 */

#include "nabu.hpp"

const char str_lit_0[] = "int";
const char str_lit_1[] = "double";
const char str_lit_2[] = "if";
const char str_lit_3[] = "else";
const char str_lit_4[] = "while";
const char str_lit_5[] = "for";
const char str_lit_6[] = "return";
const char str_lit_7[] = "break";
const char str_lit_8[] = "continue";
const char str_lit_9[] = "struct";
const char str_lit_10[] = "class";
const char str_lit_11[] = "enum";
const char str_lit_12[] = "typedef";
const char str_lit_13[] = "union";
const char str_lit_14[] = "namespace";
const char str_lit_15[] = "using";
const char str_lit_16[] = "template";
const char str_lit_17[] = "new";
const char str_lit_18[] = "delete";

namespace cpp {

//////////////////////////
// Rule tag definitions //
//////////////////////////

struct sh_keyword {};
struct sh_keyword_optn_0 {};
struct sh_keyword_optn_1 {};
struct sh_keyword_optn_10 {};
struct sh_keyword_optn_11 {};
struct sh_keyword_optn_12 {};
struct sh_keyword_optn_13 {};
struct sh_keyword_optn_14 {};
struct sh_keyword_optn_15 {};
struct sh_keyword_optn_16 {};
struct sh_keyword_optn_2 {};
struct sh_keyword_optn_3 {};
struct sh_keyword_optn_4 {};
struct sh_keyword_optn_5 {};
struct sh_keyword_optn_6 {};
struct sh_keyword_optn_7 {};
struct sh_keyword_optn_8 {};
struct sh_keyword_optn_9 {};
struct sh_main {};
struct sh_main_optn_0 {};
struct sh_main_optn_1 {};
struct sh_main_optn_2 {};
struct sh_none {};
struct sh_none_optn_0 {};
struct sh_none_optn_1 {};
struct sh_type {};
struct sh_type_optn_0 {};
struct sh_type_optn_1 {};

}

/////////////////
// Rule names //
////////////////

set_name(cpp::sh_keyword, sh_keyword);
set_name(cpp::sh_keyword_optn_0, sh_keyword_optn_0);
set_name(cpp::sh_keyword_optn_1, sh_keyword_optn_1);
set_name(cpp::sh_keyword_optn_10, sh_keyword_optn_10);
set_name(cpp::sh_keyword_optn_11, sh_keyword_optn_11);
set_name(cpp::sh_keyword_optn_12, sh_keyword_optn_12);
set_name(cpp::sh_keyword_optn_13, sh_keyword_optn_13);
set_name(cpp::sh_keyword_optn_14, sh_keyword_optn_14);
set_name(cpp::sh_keyword_optn_15, sh_keyword_optn_15);
set_name(cpp::sh_keyword_optn_16, sh_keyword_optn_16);
set_name(cpp::sh_keyword_optn_2, sh_keyword_optn_2);
set_name(cpp::sh_keyword_optn_3, sh_keyword_optn_3);
set_name(cpp::sh_keyword_optn_4, sh_keyword_optn_4);
set_name(cpp::sh_keyword_optn_5, sh_keyword_optn_5);
set_name(cpp::sh_keyword_optn_6, sh_keyword_optn_6);
set_name(cpp::sh_keyword_optn_7, sh_keyword_optn_7);
set_name(cpp::sh_keyword_optn_8, sh_keyword_optn_8);
set_name(cpp::sh_keyword_optn_9, sh_keyword_optn_9);
set_name(cpp::sh_main, sh_main);
set_name(cpp::sh_main_optn_0, sh_main_optn_0);
set_name(cpp::sh_main_optn_1, sh_main_optn_1);
set_name(cpp::sh_main_optn_2, sh_main_optn_2);
set_name(cpp::sh_none, sh_none);
set_name(cpp::sh_none_optn_0, sh_none_optn_0);
set_name(cpp::sh_none_optn_1, sh_none_optn_1);
set_name(cpp::sh_type, sh_type);
set_name(cpp::sh_type_optn_0, sh_type_optn_0);
set_name(cpp::sh_type_optn_1, sh_type_optn_1);

///////////////////////
// Rules definitions //
///////////////////////

// Lexical types
enum {
	NONE,
	TYPE,
	KEYWORD
};

nabu::ret mk_type(int type, const std::string &str) {
	return nabu::ret(new nabu::Tret <nabu::mt_ret> ({
		type,
		nabu::ret(new nabu::Tret <std::string> (str))
	}));
}

nabu::ret mk_type(int type, nabu::ret rptr) {
	return mk_type(type, nabu::get <std::string> (rptr));
}


template <> struct nabu::rule <cpp::sh_type_optn_0> : public rule <str <str_lit_0>> {};

template <> struct nabu::rule <cpp::sh_type_optn_1> : public rule <str <str_lit_1>> {};

template <> struct nabu::rule <cpp::sh_type> : public multirule <
		cpp::sh_type_optn_0,
		cpp::sh_type_optn_1
	> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_0> : public rule <str <str_lit_2>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_1> : public rule <str <str_lit_3>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_2> : public rule <str <str_lit_4>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_3> : public rule <str <str_lit_5>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_4> : public rule <str <str_lit_6>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_5> : public rule <str <str_lit_7>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_6> : public rule <str <str_lit_8>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_7> : public rule <str <str_lit_9>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_8> : public rule <str <str_lit_10>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_9> : public rule <str <str_lit_11>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_10> : public rule <str <str_lit_12>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_11> : public rule <str <str_lit_13>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_12> : public rule <str <str_lit_14>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_13> : public rule <str <str_lit_15>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_14> : public rule <str <str_lit_16>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_15> : public rule <str <str_lit_17>> {};

template <> struct nabu::rule <cpp::sh_keyword_optn_16> : public rule <str <str_lit_18>> {};

template <> struct nabu::rule <cpp::sh_keyword> : public multirule <
		cpp::sh_keyword_optn_0,
		cpp::sh_keyword_optn_1,
		cpp::sh_keyword_optn_2,
		cpp::sh_keyword_optn_3,
		cpp::sh_keyword_optn_4,
		cpp::sh_keyword_optn_5,
		cpp::sh_keyword_optn_6,
		cpp::sh_keyword_optn_7,
		cpp::sh_keyword_optn_8,
		cpp::sh_keyword_optn_9,
		cpp::sh_keyword_optn_10,
		cpp::sh_keyword_optn_11,
		cpp::sh_keyword_optn_12,
		cpp::sh_keyword_optn_13,
		cpp::sh_keyword_optn_14,
		cpp::sh_keyword_optn_15,
		cpp::sh_keyword_optn_16
	> {};

template <> struct nabu::rule <cpp::sh_none_optn_0> : public rule <nabu::word> {};

template <>
struct nabu::rule <cpp::sh_none_optn_1> : public rule <nabu::space> {
	static ret value(Feeder *fd) {
		// Predefined values
		ret _val = rule <nabu::space> ::value(fd);
		if (!_val)
			return nullptr;

		// User source
		char c = nabu::get <char> (_val);
		std::string str(1, c);
		return ret(new nabu::Tret <std::string> (str));
	
	}
};

template <> struct nabu::rule <cpp::sh_none> : public multirule <
		cpp::sh_none_optn_0,
		cpp::sh_none_optn_1
	> {};

template <>
struct nabu::rule <cpp::sh_main_optn_0> : public rule <cpp::sh_type> {
	static ret value(Feeder *fd) {
		// Predefined values
		ret _val = rule <cpp::sh_type> ::value(fd);
		if (!_val)
			return nullptr;

		// User source
		return mk_type(TYPE, _val);
	}
};

template <>
struct nabu::rule <cpp::sh_main_optn_1> : public rule <cpp::sh_keyword> {
	static ret value(Feeder *fd) {
		// Predefined values
		ret _val = rule <cpp::sh_keyword> ::value(fd);
		if (!_val)
			return nullptr;

		// User source
		return mk_type(KEYWORD, _val);
	}
};

template <>
struct nabu::rule <cpp::sh_main_optn_2> : public rule <cpp::sh_none> {
	static ret value(Feeder *fd) {
		// Predefined values
		ret _val = rule <cpp::sh_none> ::value(fd);
		if (!_val)
			return nullptr;

		// User source
		return mk_type(NONE, _val);
	}
};

template <> struct nabu::rule <cpp::sh_main> : public multirule <
		cpp::sh_main_optn_0,
		cpp::sh_main_optn_1,
		cpp::sh_main_optn_2
	> {};

